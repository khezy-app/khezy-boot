package io.github.khezyapp.grammar;

import io.github.khezyapp.grammar.ast.*;
import io.github.khezyapp.grammar.ast.operand.AggregateOperand;
import io.github.khezyapp.grammar.ast.operand.LiteralOperand;
import io.github.khezyapp.grammar.ast.operand.Operand;
import io.github.khezyapp.grammar.ast.operand.PathOperand;
import io.github.khezyapp.query.FilterSpecBaseVisitor;
import io.github.khezyapp.query.FilterSpecParser;
import org.antlr.v4.runtime.RuleContext;

import java.util.List;
import java.util.Objects;

/**
 * Visitor implementation that converts ANTLR parse tree contexts into a structured {@link ASTSpec} tree.
 * <p>
 * This class extends the base visitor generated by ANTLR to map query language syntax
 * into domain-specific specification objects.
 * </p>
 */
public class ASTSpecVisitor extends FilterSpecBaseVisitor<ASTSpec> {

    /**
     * Visits the root query context to build a complete {@link QuerySpec}.
     *
     * @param ctx the root query context
     * @return a new query specification
     */
    @Override
    public ASTSpec visitRootQuery(final FilterSpecParser.RootQueryContext ctx) {
        final var where = visit(ctx.where);
        final var having = Objects.isNull(ctx.havingClause()) ? null : visit(ctx.havingClause());
        final var groupBy = resolveGroupBy(ctx.groupByClause());
        return new QuerySpec(where, having, groupBy);
    }

    /**
     * Resolves the GROUP BY clause from the parser context.
     *
     * @param ctx the group by clause context
     * @return a {@link GroupBy} instance, or {@code null} if no clause exists
     */
    private GroupBy resolveGroupBy(final FilterSpecParser.GroupByClauseContext ctx) {
        if (Objects.isNull(ctx)) {
            return null;
        }
        final var values = ctx.groupItem()
                .stream()
                .map(this::resolveGroupItemContext)
                .toList();
        return new GroupBy(values);
    }

    /**
     * Visits the HAVING clause context.
     *
     * @param ctx the having clause context
     * @return the resulting specification tree
     */
    @Override
    public ASTSpec visitHavingClause(final FilterSpecParser.HavingClauseContext ctx) {
        return visit(ctx.orExpr());
    }

    /**
     * Visits a logical OR expression context and creates a {@link LogicalOrSpec}.
     *
     * @param ctx the OR expression context
     * @return a logical OR specification
     */
    @Override
    public ASTSpec visitLogicalOrExpr(final FilterSpecParser.LogicalOrExprContext ctx) {
        final var orExpr = ctx.andExpr()
                .stream()
                .map(this::visit)
                .filter(Objects::nonNull)
                .toList();
        return new LogicalOrSpec(orExpr);
    }

    /**
     * Visits a logical AND expression context and creates a {@link LogicalAndSpec}.
     *
     * @param ctx the AND expression context
     * @return a logical AND specification
     */
    @Override
    public ASTSpec visitLogicalAndExpr(final FilterSpecParser.LogicalAndExprContext ctx) {
        final var andExpr = ctx.primaryExpr()
                .stream()
                .map(this::visit)
                .filter(Objects::nonNull)
                .toList();
        return new LogicalAndSpec(andExpr);
    }

    /**
     * Visits a parenthesized expression, unwrapping the inner expression.
     *
     * @param ctx the parenthesis context
     * @return the inner specification
     */
    @Override
    public ASTSpec visitParenExpr(final FilterSpecParser.ParenExprContext ctx) {
        return visit(ctx.orExpr());
    }

    /**
     * Visits the base comparison context and merges the left operand and join type with the comparison rest.
     *
     * @param ctx the base comparison context
     * @return a fully populated comparison specification
     * @throws IllegalArgumentException if the comparison type is unknown
     */
    @Override
    public ASTSpec visitBaseComparison(final FilterSpecParser.BaseComparisonContext ctx) {
        final var left = resolveSelectableContext(ctx.left);
        final var joinType = resolveJoinType(ctx);
        final var rest = visit(ctx.comparisonRest());
        if (rest instanceof BinaryComparisonSpec cs) {
            return cs.mutate()
                    .left(left)
                    .joinType(joinType)
                    .build();
        } else if (rest instanceof InComparisonSpec is) {
            return is.mutate()
                    .left(left)
                    .joinType(joinType)
                    .build();
        } else if (rest instanceof BetweenComparisonSpec bs) {
            return bs.mutate()
                    .left(left)
                    .joinType(joinType)
                    .build();
        } else if (rest instanceof UnaryComparisonSpec us) {
            return us.mutate()
                    .left(left)
                    .joinType(joinType)
                    .build();
        }
        throw new IllegalArgumentException("Unknow comparison type class: " + rest.getClass().getSimpleName());
    }

    /**
     * Visits a simple binary comparison (e.g., =, !=, <).
     *
     * @param ctx the simple comparison context
     * @return a partial binary comparison specification
     */
    @Override
    public ASTSpec visitSimpleComparison(final FilterSpecParser.SimpleComparisonContext ctx) {
        final var operator = ComparisonOperator.of(ctx.operator().getText());
        final var value = resolveValueContext(ctx.value());
        return new BinaryComparisonSpec.Builder()
                .operator(operator)
                .right(value)
                .build();
    }

    /**
     * Visits an IN comparison context.
     *
     * @param ctx the IN comparison context
     * @return a partial IN comparison specification
     */
    @Override
    public ASTSpec visitInComparison(final FilterSpecParser.InComparisonContext ctx) {
        final var values = ctx.value().stream()
                .map(this::resolveValueContext)
                .toList();
        return new InComparisonSpec.Builder()
                .right(values)
                .build();
    }

    /**
     * Visits a BETWEEN comparison context.
     *
     * @param ctx the BETWEEN comparison context
     * @return a partial BETWEEN comparison specification
     */
    @Override
    public ASTSpec visitBetweenComparison(final FilterSpecParser.BetweenComparisonContext ctx) {
        final var from = resolveValueContext(ctx.start);
        final var to = resolveValueContext(ctx.end);
        return new BetweenComparisonSpec.Builder()
                .from(from)
                .to(to)
                .build();
    }

    /**
     * Visits an IS NULL comparison context.
     *
     * @param ctx the null comparison context
     * @return a partial unary comparison specification for null check
     */
    @Override
    public ASTSpec visitNullComparison(final FilterSpecParser.NullComparisonContext ctx) {
        return new UnaryComparisonSpec.Builder()
                .operator(ComparisonOperator.IS_NULL)
                .build();
    }

    /**
     * Visits an IS NOT NULL comparison context.
     *
     * @param ctx the not null comparison context
     * @return a partial unary comparison specification for not-null check
     */
    @Override
    public ASTSpec visitNotNullComparison(final FilterSpecParser.NotNullComparisonContext ctx) {
        return new UnaryComparisonSpec.Builder()
                .operator(ComparisonOperator.IS_NOT_NULL)
                .build();
    }

    /**
     * Resolves the join type from the comparison context, defaulting to INNER.
     *
     * @param ctx the comparison context
     * @return the resolved join type
     */
    private JoinType resolveJoinType(final FilterSpecParser.BaseComparisonContext ctx) {
        return Objects.isNull(ctx.joinType()) ?
                JoinType.INNER :
                JoinType.of(ctx.joinType().getText());
    }

    /**
     * Resolves a selectable context into either a path or aggregate operand.
     *
     * @param ctx the selectable context
     * @return the resolved operand
     */
    private Operand resolveSelectableContext(final FilterSpecParser.SelectableContext ctx) {
        if (ctx instanceof FilterSpecParser.PathSelectableContext pathCtx) {
           return resolvePathOperand(pathCtx.path());
        } else {
            final var aggCtx = (FilterSpecParser.AggregateSelectableContext) ctx;
            return resolveAggOperand(aggCtx.aggregateFunction());
        }
    }

    /**
     * Resolves a group item context into an operand.
     *
     * @param ctx the group item context
     * @return the resolved operand
     */
    private Operand resolveGroupItemContext(final FilterSpecParser.GroupItemContext ctx) {
        if (ctx instanceof FilterSpecParser.PathGroupItemContext pathCtx) {
            return resolvePathOperand(pathCtx.path());
        } else {
            final var aggCtx = (FilterSpecParser.AggregateGroupItemContext) ctx;
            return resolveAggOperand(aggCtx.aggregateFunction());
        }
    }

    /**
     * Converts a path context into a {@link PathOperand}.
     *
     * @param ctx the path context
     * @return the path operand
     */
    private PathOperand resolvePathOperand(final FilterSpecParser.PathContext ctx) {
        final var identifiers = ctx.anyIdentifier()
                .stream()
                .map(RuleContext::getText)
                .toList();
        return new PathOperand(identifiers, ctx.getText());
    }

    /**
     * Converts an aggregate function context into an {@link AggregateOperand}.
     *
     * @param ctx the aggregate context
     * @return the aggregate operand
     */
    private AggregateOperand resolveAggOperand(final FilterSpecParser.AggregateFunctionContext ctx) {
        final var pathOperand = Objects.nonNull(ctx.path()) ?
                resolvePathOperand(ctx.path()) :
                new PathOperand(List.of("*"), "*");
        final AggregateFunction aggFunc;
        if (Objects.nonNull(ctx.COUNT())) {
            aggFunc = AggregateFunction.COUNT;
        } else if (Objects.nonNull(ctx.SUM())) {
            aggFunc = AggregateFunction.SUM;
        } else if (Objects.nonNull(ctx.AVG())) {
            aggFunc = AggregateFunction.AVG;
        } else if (Objects.nonNull(ctx.MIN())) {
            aggFunc = AggregateFunction.MIN;
        } else {
            aggFunc = AggregateFunction.MAX;
        }
        return new AggregateOperand(aggFunc, pathOperand);
    }

    /**
     * Resolves a value context into a literal, path, or aggregate operand.
     *
     * @param ctx the value context
     * @return the resolved operand
     */
    private Operand resolveValueContext(final FilterSpecParser.ValueContext ctx) {
        if (Objects.nonNull(ctx.path())) {
            return resolvePathOperand(ctx.path());
        } else if (Objects.nonNull(ctx.aggregateFunction())) {
            return resolveAggOperand(ctx.aggregateFunction());
        } else {
            if (Objects.nonNull(ctx.STRING())) {
                var string = ctx.STRING().getText();
                if (string.startsWith("'")) {
                    string = string.substring(1);
                }
                if (string.endsWith("'")) {
                    string = string.substring(0, string.length() - 1);
                }
                return new LiteralOperand(string);
            }

            // Else it is number rule
            final var number = ctx.NUMBER().getText();
            final Object value;
            if (number.contains(".")) {
                value = Double.parseDouble(number);
            } else {
                value = Long.parseLong(number);
            }
            return new LiteralOperand(value);
        }
    }

}
